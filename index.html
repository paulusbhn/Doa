<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f7a366ba5b0fd915ba20aebfd13a8cd82c431813491a357d1df4feb4b99977801aafb78e2009e6ff9e9a8e32794a0980774f27b58675710779098efd706ccc7aa98adb37b4a7e9c8e74667ba3ef1240b1f2cc75f6706ff015c23627ddcb26d8e062fea6f9f91f21225306178cbd3a0d28e22346afa1ea6062cf4da7b7beacb70448b733e1097a1226efcbc4aab8d7858a258a118a233743bc48f2073a0a4c4d0677594ef8910b9b02a75c67cc31509df69ef7318f4db2f338911b1422a0ca02637e6f5188db1bd08c7958fcc2da39be8ae341a0f6678bcc391bb0d958d4360bd929815015965bb30791b6ba304c62b0e62b20199ad701a644c3d2c93cb407872a1669ba4d9e6e7788dc4062bbeeb35843dddb39027a70ab6defe8931348327edfc8746d80986618a77fa5e13b715e5ac1688574add8a40a47b67a15870b7a5f23b91e6e40d8610494e3d00e884c076aad9fea7f80c90e00ee39f0f341b31dd5b3ce4daafb97343c495153e13431618d5c7009fcd4816e877be566fdda790cdf14950d2033d7445e1dcec6bdea670130e55cb1f6e55a58014a542192a904be009fdf95bc83a23a1da426327df880af4c76fcc1ac0c9b86fc080f320f721f42b986eece2a14473583a990bd315d8f1854f4b7fedfba012b474c09b4467e23dca75353eb176bc1ab291f2b562069923a528c484737262583ca5edaf5e6bfa796286059958a38687334764c1704275b3686e2f643e5b4ac9344fe88d9dd07950a809561f136b5b1e467df1f563e0fa8c6e98432cbdfc487f8d8e9a56b3f1af1f477f6767d19f6a675e6d395513c0572ce081eab4ae4d4ad060ed7606cceca975b614294e1a66b9be4a9c35094e73ca5f28281ac26b180fb5357ab36a765b2b9c7e4a24b7a0180557b0520c9ce136862f904ac7aea245cbf187ac5f5a29210db27f0b1f7df0bbdb56a519d1b991483cb2844b2296f0b99e8a86f60756b76a472a0af8608e606354c7ba2b6400a327269836ffa6b602917a9c17096c99b3a34a3b58da707904e1cf96530e10f9074818d92b80466a68f6bd8166c2c273150a15c06278bf5f66d430a2a935ddb737b6289f03ff3868417be70be67590bb3267c09534189a47bd5b53de907b5a3eb5d629c4d43b0f8ac096f6050200bd1ba537f100b3bcf43cb7bd7d354be56af8f82cbc04ac409cf9af1005d25f82f0b6cf6c9d8558677caf53b95304f9fa4d872a72c73871c169e44401cc46cb60b7409fc716683395d6076b697148e99e6bcfe5b0b9936df25f3c00baca092ba0254365df2efe4d8c77a546a308351042a9f48ce7ee0a3d44207b832f71761fdf3033be2c5896878270725050eec9c2301a0ab0cbf36570f0adc03dd407305cf56662d4d4d01a534fd6793676841a8f8bb2eab0ccec71d4cae0058485f67bbeaf4ab8477f684161f84d7ca0ef6a54aabbb0ef976a9b62fadd32c3ef09bdb5851e5c76556683005c646ca66117e074580d3bed63a68e21733c107836b7fb13ace9705e6bd8b03600d9cbb5885bdba3d2d166de666cee3775459259937099658263a2622ccf5ed56eb57c27ade93c7e8e5c9240661799c252e282c651d29bc02232c1cef708ff2cceed6b49f4ef4fb732413d39031ed401e4c382c2a8850f54966d68c0fceeae01102f187271f81993bbffd586548de6ba012aece55457ab77e1b6262c3ae471e9b0cffb3e703e97d578a9254bbdcae5d0db3730b9e20da08a221f2d4abacb436bbc04651c063f3b81d6fad7086a843c7967d50671bbc128bf90a6e9e4d715ff6ad79afa63e9f5f1f05c39e3bd49918bfec8fb99d8ff5add6e212147ec0e00083d57a345cc386e059f48faf882a045047d3ba27cb991355635166ca82e1f4800e8889bf0733f2723d2cfb903f521b71b22bb23b8aad00df94415bd9ec74a7e85a09ddf93baed348842cd9777ba5dd60d0b4363c32f3652cde2f729bc30b86b15741423dcb439862702ce4542277da05c0364b46c77145b537613019e2f56d03324b9ded450c0e66a8cc344af72d8c13838f428713ee3e9a2b1779210faaeace1bae9363b32713fceae396df94d28fd6b5852a86f2e0b362db2b7fbcfe9369772a61b84698d2636cf7fe70e8454b2356c925a5e2e1bd88806120bdb89118f3ff166f7f7a47c890fd640d568e7d5137f9f95eb22927c75abf6745357416fefb77c78d20d289bf6499e8404f905f2c73f3e764ccd2a4171622e631791917819234feaf9641ee9b0ad49487fa883087453540febcce4d94896df5b6a9d3226384eba21afe0cdead5e8743a8ef51ff6ebcaf996102e847bd30f5c720da109be9bfef5c58ca6f1e3a5eba9e18506b7a1907ba49383ecab01fc4a5fd2072dbe711028b58da30619184ebe0236041be8e15ef77119a1add02045dc7e763be53fd832001fddd580cc33d10f41aab61fa2649c5d8e7a1f52591f8a86d69ca2bfa92cbf537bc8ad4f2d4c3a078c7cb609db2d516738f9472f610c965c8cc2ebbb664be2ad8b8320d6361be384c6e1cf99ae72fe35301c9d597ac942f9dcf50e6986cc9c2f6c478aee59369ad02efde76ce3e3b67fd16b9bd56b0f3f1c8b2681dc6eda782679560c9da1dceaa4513786327c88634a5b57c5a6a7743e3ca963b17f68d4ef03acc8946a3e1d047bae9d0b021eb9af15def508c8fbea1d6ff106b7d72f180e537b495e317cd4ec35a2d9bd292b37cf77c9641542431020057bb7f67c5c9c89951a228d73dee763a1becc20e63816990822a29c045fe05c61eb0495dbce236af91c917e2addfa4727e459bfc25092e8daaac677c98c4d1c2efc44aa2939ebff4c80457b05f95e36a65393ebc8577238bffec6f93f9965008c297aef89f090282f78accded75256095d3982aa3786c2406e146d2255c6a9159e6c8b0cd13c03a092bdd2e6c093439d7de4b85ab65339dac3f5e90ccc0aede0b81059fc1f7cb257acd5ce691c81be6ea0c656f7782e3e1a2c49dfb2fd24da7e6c0ea52bf4e79cb5ff4848f96bd38dce336c67db3195bf78558fc4e1cbfbbe48a45a64ef8439c953a08182d89ca551390e6567492b242c513a3376da17f1d9112c54f017899ac69bd7e994da76dbcfc55d6ca208a0a8e4e7dea7c23e463976a951aa4ae5179b6d612eb8ceb74675b07ff03e571a912f47bc1273bd2e82c4f0965195fbcb56263bdd4d96a284b3281c31e0baba3481cac3c59d64e7cde037e6eb35597ae85225f2c7bcab2ff2f0432c361a251bce3fa2143ebd23fed0d71c654ebbf78d00612e0817cb122ebac8a76865216ac1771e76c062a7149b7d5e4e4f34b62e632f1b26d1e5d3b81ba328bd149158e9b5fbe1275bdc955f4689fd4b21a338d25c0ee55cceebc78dbefed144a1ac48738a276152d9893e7bdf9a2244c97b7a9201ff6ce5e450b78559c7a2014f19ffd49f391d9f56b546c8810a27ded2f4e3367722c1c26bd1d57149cac8973c89ddde590537d03bb0c9c50da43247df72b4685c79553f2771a1c02d838d7262ef6579176849be1b7ca868d6f664e1182ff5b44e9cf6a077adcbe8f1288732cd78b61dbf37d3dab8cea878edaa8e1af6e587f7a3e467eeff32f28c70467103932904ab8a01878dc81b198562cc9d80fc2bf2dedb362a01e6041b593f2e4339fadff7422640053bc2b538d4cbe7640b62d0d9cff15d9ba5cdc9cd180c57c150f0b1297c23ce636a29c806090c8e874d586e6aa9d0ecf80652dd3b9af68a20809d760e44edc5473983c386eb139b181d708c7513f85b176d5edf4970933669cfdd0fa34b464f8ecef8db6cca8b337bd830ac18de200fa19a373f93013f7403fd2dac13dc42d53406d35ed739482429c76f503f936053370373e64eb1d969a017b06ac88bb1ce3ff756b3516006f2a8301bcc1ae433beaa288689b89d601662af230ab86729a92d998269bc049cfda024c5400fdecb4b36eb487237583d57d345af4910e4435ff147a28e4a79739fbab6578a719e1d137810afe131c7f9dd279c4ab5aa6904f7e29f187c3b74e47070802f3e9576a4f103b550df71da9af66c60a3eb24a2e4e0317131dbf188322b19b55b8b96049bbadebdd4d81acb55ca731de84c874cba64d159dff50cc973a96570398cfa29fa79cc2e421a4eadf84faa93d205c7b007c9b08d65932622daee4f347bc204703e243003b131b1c61191b947d3aad0d00460788628ed898ed7ba69b2013e8826fb281962bb54ccb4261007abe8627c3d38c977390a275b3e7a6a2dab67a091fc22181e6d40e5306141ea0a771f5128fda89de55e51b18b29412ddb66e7b55a60fed64b2cc0ef9d5e8c16bffc7e2acdad3e20580da2d1f5da8484c62cc7a54ef571c48945663d3096b57fa02ee7e783f1d2c2de4142b70a4def1be0359b54a445e84344e7c44f872609df6ee75b22f9f22811f1e3ba8d6616a9951776239fb1501ed3e863e7cd920e9b01e4e77285f55488f4e435597de1cf46910f1e3ad089a4a098f70df8c74cc564e6eaa5e57ecc1d569d32242ae25d20169e1fa6ccfde83b4a1b0aa8563a3aeb3b6445e54ec8593bb3685f8ed94c42d36a209ee7a14c8d3984c0784c92fa1f6fe3f75b3d57e43a60ca8b589c45d0e93812ddf31080c193ea4a68f0cc08b283c06c672f522011ff9a877ae07453a08815e95e8e90c9979af344e9e33600aa798804fb957fb2469d2777918ab2b45cf2be2d5e1b4baff06f2eae784284a9019d2a6c4e883eaa805918261720214ccab8637d7862311c0bb85d76b91153f9fbefc614ce3bd6089a4ee96148a445db23208434842f959073371213f3a0e602c82c1aac3b81484c11ead28cd18ca6125fb977267875fb15ff9c965cd0f06b7354a5ad062f0eafac296fcf3b3d8cce31776da82775660e60c71f848af033bfbb7de01264cdbeaec1bce9152e7c231d3201dd97f474bf39304abec29e24b7720b0aced5acfabdddf0e1b4ff75b5d962284b6ebc4910cf031c27b884081e689a1f2e7f20e40f30eaf86d95fa57f9b87a036bdc64c849c095336f872cfcfa73e98c46ea1d1aa660e1fea49712b0f8d8a911d5c37520e7df66c35a0c8fb6e5f1c8c488e7751546de48919bfe5fbb34aed8bf8bc396eafce3aede5baa83c75ba1d9ed14ef6e39c19304336d9ebce7636579706ec2f0fae86ea5c95d18b0e613f8eae1e9d43b1ac7b0b433ae20293425a28516d7184d272e40c4e4a40f50851d90239c05aded8943bf02f2ddb5f63491e68912ddd1ec4c1f8726cbf52a08512b26e9aa07cb8ce6d885d7179787e652093552ddaf84d0f9ecfb673466a977b67bedb1a1579a60d2a3408c2f8841ff852e26fb1f4138a90cc8a7e7b2ea62583bdddb585a0c82255a29f409bbb02a0a91fa38d98eefd723ec06626d29428e9483af16a2248a3ea33b5feabac7f53824671e7c89becfbd75c0865385ac1026f1a86fe5f192e100b881465afdfcaffb13315753d3632e6458a5de24aa4bfe4c6aa872afaaefdca7d64d3d7b23c04b11901181d5536ef53e49e3433d970d856d09a71f357b5c8faa53ebe443cb2b8f70749f7054b4f0461b19661e889787f8ff87569a82cc161e8168b4e3e5ef154274f33066603b05587a781fee1808561802849fd2e448d0ceb3cb77d98fc87f8847b78b8f8a3ddaa8ba559ee9c140eda22e95d8876ba9597728fb6b93bc9b8f6e5a5ead8b0ecb5d2727f384f4e004c7ddeb981e00fe9be64d8fb8963759dc7b78f809a16ec19803b38b70b9c38c8a76b5b20507100eb2819baea85164462d70cf6f691c2eee8fb1520e4fe5c1ce5a456f8958a596d6733880c6ac04924a764a8416557f7d09597142825f44cb6dc2abe1f77df17992355e8c9a0f77c583efbeb728f6431f27435426d23f3f72558898d41dc847930d41ec51fb297ef8dec4b9d692d72ef08fbbf09481c9ba0ace06c496d7021ffd45707945256378b7e3d31dae690caf1bf9c5aed0ed5fab52d1efbd1f2b3cd9af44ce1b049142b5d058632d2678b62dd4844838607fa47ab4533bc43ca78c1e19b13ccc42b4566f35689930ad616057c614fed08cdccf221b4863cb23e5dace8a8a0aa1ebfcdea3eee9b8bd4e6dfab4b2ddef9680840c1ba0f5da002d4d296efd7fdf49931d6980ac7e0ef7ed6c1e09028c6f1c99883c6bc0d8b21c6102841aa8573a4dd9a94eafddfd9e1c43c8be47ff883a6da18c7e3faa84b0181b1ffb34c157a1758df14a7de5c3cdbdc6840a7c4c753ab5942ba57c39e797be00263b09f3e4c51ac9e9fae5ca36c0eac83af5de0e044288e35fcbd2a4f1900d88ca91bb726313a097d4f36c33b7a1cbdaa97784a9df9a1716dd65867057350707b06bf713a5547fca2704a49b07f100ad410ceb2e655c572b92114df5f0dbaed86e6ea3dd783292ff48bff79aeb4fcf96fb178bdc73528c7f82b5cce87a033e3ab4eb9864ccc28d1ef701171b46423a79128330faa12e9f0e0cc8ddc3abcf777d41e0cf713674f673409ee2ba0d0d486412768060568c144a27fc58d3146de20cc375404ed42284a011a968c07692cb32a5cbfe165c4670e5515506d9f16bab07528450b88f715fe029753e21191a0923c533ce20b8a16e5e47283747bb045e2bb664f098ae590607915081eed1d8efd0c345fd4b7ca6fcb075b1515aa912e35bba7f130f2d12d5713a5a331610b88855a17bff378516e98646c588521c4c25ce437237b85480362febdfa93c1a803f643e10df98a53ebe45e9bd39a8adeaa901bcfab2f54e144a2f2c38565d540393c68a745d311d2ecb0b148aca89fe0b579377cc5b996a8676ad17582c0ca6147125ef48accbfe8b0bd8102fcdda3a65ebdeb71a4b8883f62c10611e40c2e7cd8a7c5826aa2ae71551cde8c3f5b9be7d5c3314f823cf4382fe620783a2f87f7c6fd7f1e9a216834b257f422fc4dd30628dc86bf8618de1ddc6ce4b82d72694d715628e9fe89a031dc0ac180766705841bd6896f4245f698416e64e1af7a5ea6bdbc77388ddbbf686997c9ea13c8c54f0bdeafc148d72706bd27ec175fded5bb37ec05d58efdb45e586ac08dad1b68376c7bdab9857629a57443fb5031221944218305d37ff40a19b35c8952f69d77f9c674e0135a34af625362b3086afd3fe291825a509d9b0c11070fc2433602215d8a43e167d24081603e1ac1569182fcc1f9fa76be8817d663d47e3e1e92e03205caef27347436111a9ed8a6e84cd72ff3c7b63b40196ce41af5623009e684db8ed33b4767744f5b63cda9c789aad556f9b2fd10329714f1e886dfa74cea7f55eeca7134f7fc9feaf2424ae293477bb0823d8a6cc6c9bcaf042288828db952f8ccce87b516ede9acb3e95c4314c1768af1c287916fc06c2998b79e49ee02f15eae3a80ac3c2ac718e6a8f825ed1a39accf9cddb7485289c3e26c28ec615a04008017c77e47374f281586099a9b5487bd22d20cc751802d08fbb733b44a332af941ad96c5215f0e428c8d8904b0699d530812151d3f7be564d14d74941b78a90f314cd1fcbbfaa8c5178b41523ca0fa05283b014a11469a534264b5cac8293e7a52d92ec7dfd05f9b20417b145f3b6bd245b9cd41a6263a177d07793b4fff9e2a6e237b38229d0707fcc70e945f9a97b78854ea4fc88b680318c666b7cdf1f640179dd27b85fdc6c2b117649a05cdcd248ce79acc73c80b1cc1daae986f1b91db14a0c68a6b17824a43a8e630a65a955a8384e88577a702709ff25ac4f9c72cb4acc8e7ce2f06bef0c5eca839783c702857efc5dc5ff0f3bfb162c7374983590b3caae238840301bcee3d2bbc34383b1ce33bb1f5f64d9b05f92a842d55b6ae80cf012a5714ea2023d4e1964712dc3ee85fdc4f79db9dc8157f728b8022463940b684b739a90a91d73b4a8c34499b4c8a53832cb952a129f1700767ea9b21d375faf3798a3ca07aa0be66b50b1937e46b428b798c7981f7c0736f0ee940c8821b7905609b8e93f44c416aeb7fde6ceca1c1477bf6e052454ac5223e77d16d76bca0ac6fbeab14d7a332e5679a18d1a7a410951d8664aeb361350f9559f7fcee862b81ba307876b2839c7447f94f4d9e5b1a88285d21cbe2f6adb639002c4966c60725a960f2b39ea4b4aeaad8de2c03d191974b9f5cf51846efdd95519e57df9392dfbefcc1d2384d8815d66f8cafee7bcb8ec792984ebe31be9fd34a5b81f481e2984c90a987fcd374f52d3c0ac9e81bb19093c11542d2983d1205866a563c685928c8152390fa18909132c30228abaa30d85e10a90876b8897b3a41cd16bdf55ee441f7885f9f8fc7c1d734557ca89b76d3465f8ccc17a7bb08aab9c20d38907977053ba5fd86e7f176f938d7901b48c83de1e3ebf75ea7ef7627d68d2d5b15d1fc6d156404c924c254a5f319143735c6164f97870129f9c133afa818d2459bbdb0df5e0ce4ef6c20abeec0b973460f1b769d0971388b141544bc13998bd2778588efd5fbdfa1a5d49e4b518a97e342ab4ec4d0523fbf260890b5dd7a6b4fafc315b14813e9e9b744a8a5f08e3a0102f369587eb2cc2717fa4ed9410d01b1b1adfd43eed372998ab81dab3fd5f05164a8781d9407cb9addc2b069cd2c789e88fba358888802d4ff131736570e7eed962be612ad847a77787e564b45196ecfec206a6235bdda898703f080fce62dc5c4ef770ac024a0a8fe01e8e5aeb9bc88816c3f5ef8c87fb3faa9264feb0e77a117e63848e696fa5ec5c02396b852c049caf7c0756d0d9939b9e255a678697fe2e7a3469bf808b6853eb701796eac2283d828e350dde95f866c2efd46d6a3096d95d4be1c3620e8e0886bff220f01be1fc4d0b203c62f7df8d171e601310cdd2c32401cb2f57fda59a879f92811a2076aef10dc7b97b8df0a4cd95a56f50bfcf7b0c0f3dfb521fe26297dd958091c28f9c42f65d9166e784df1834f99ddc14ca81f5707e90131f6726afc86e0c99cd448584b6dcb68d5d75d543db5dc8a5b5df93b5a01b350757a26b12d4b13d392819ffd8d3d3905ef14f429254ee80774e6f9d18115a5848cdfe494f98dca4a662f1e6b66d5926c5d2a4498cf252ccd4f5a5e9d3936f66d2afb4ef3f228d37b532fbd78df30086e2a163d2dbaf0012f16363ac246313bd84942353d59cfd585099488fb4e6cd361abb74e2672550f76b3e4fafad20daec21e0b1e4d549a1155a7ca5638552437f1254e240763353bd89241a111ef99794498823e02ceb787e4d0609c58bfe6afec3866e570a50ab3a35f10f451d043cf75abe8c9f55383584d1722e97d7158efebaa1a548fa67b78f65d1259d73a6877adf878aa4ba1f686405bd82f1acd0e4450b80e761f567b6f63a9696edfa09396e225a3f5f92c058ba58ad36262163f2c39ccbae2977c655c82d8731c8077470f7425db43a4f9fed5b75932013cfaeca50775d38a96385df69b7ef6da067d976b897e5ca7b49ca07da64e77232ab46fd922b7979f86e6e0d0ea4e254acc56c2a986f83b72206667a50a0b9caeb3f401ab2567924d7b4df9f7ea232460ff8976de056fc48ac3d4bdc28cbb03f5be7cb6ba4c48cefcd0a9f9c6f61d1521bc54e73464d0b287eb5d1937448b293ad4c022666e4316d45d497babd78eee82b4a24a0fd6a613148b754c5769d1899fadfa059b762a4a0f4eaf143e4325ec2d99e9372a812f474490548c48c4e4dbab5b89d6aabac62e3d768c8ae2f9b0269fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe2156a5a35823827d3bda09898f59d5"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
