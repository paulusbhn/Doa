<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a8413ce872ea302790308df5fed5d17c2753766b2716b4ba2d788ae0a1a4f6c798d817432bebb9282fc65b1df551714c7001adfb08a1a7996595813c4fe659a01c2961e815dd5e4173a7471c658451bad49fe5259150e8c18d8183fabab2834e713d72b08d3b82039ee6072162a94afd577a186a3d07c9d46646c079eccc7d459080dbcfc32e7f687ac72e6b6af8c4a3a8ddd9b47f38b7ee71735ee86a38827b5a7f86db959b40fcef5f08d52054280c1a3dcb2adac99156604f36fa1aa632aefa5da46756102c1570c7efcd31c6a086081e20e405034b3749f65aa21178a13a5fe124055d7e5831294b5fda47056b9f4a18fc8607a9f64c1f1d1eefc175c893ffc407fa1e99d3895716072675327645a48da80a6e273fe9e20b33f0ba715f31680bce48b002ba52fe2d35dd41a70f51abb144326f3d4443362dade45ec69235d6cf64ad27585f4024b90290c8cc018045ce074439885b3f2a513e3000776f376c39f7af3ff6fa8921f0111be89f429c88aadd5f00d264f865ece21a3d4d04ab2db2d0f884dbddef41dac60b3d9e1b4c545e6dad967f7f8be60d163afbe2e2abf7616a7a2315973b5d31de1bb55455a17b9e28531139f741c25060ccc2b89201d58e56576cf99b389f1fb11e992a605fb6d5852ea0286d1b96db2e489a9447c4281bcb0090cd98c156c28c5aeaead99e14ee633c81bfa972ba8333492f6b041625e126ab06d767c3838207a450a237cfdaf2e3dfc3acb592ac5f53c14ed01a4cc784a989761c9cd68b374b533a113a8c53ecbcc224bf88a179ce41fdbb98ec9839f5db24f70387913e14038064e3dd4f7794243dbc6b4acd37fa1ce0bf9d7945952020e38318306a58dcc6f37fcca672ed79528a55e2be71656d287a993f4605f31977b872b8ff42392ca7e0b269c574512496754c3b7e177c2f1a3ed87829396d91e39452ee211f64fc3c263ef44a04786a85d23077378e95c2f9c34726ebc331069a295686b4b5596e4d8954c796c5748f864a534d2a363f66d63d275521c2b5908c6f796e0a0aad9d89aca92c7f6042ea2ba03dc95546f5a5210a72f2ec06e3f33bd5749304cdd6461c27077fbd46889be1046f5a67522699232b84ea39eda14b45eb20066bea5bc147febd2c995db4e29e62b2ac39ba7917228ec866b7fd31101503294fbf72c98fc53e4c46b506619f9ca816f307c5ea62809b8e1e13095816ff14df6e4b42b9a26170a7cd8145f2098f299c59eda61b3cdd527314dc2fd472871de85457dbe9efb1682522caa528648496ec6ee4f52dca509e29bf0abc7b99526770b738f176b0c906a8140b2621154074a9225dd7a4c9af15e7900d08dd836453636577b4d0ce0fca5a83274a6ad41d24db8eb63258fcf6a11109a06fea1c14239dea24ad5e14c135aa39e8794ffaa9dd12a33a7c48ac2a2306939d689b215bff2ee1bde0d2358ae3b38ace9b3f9740ab928c98bec82e75848a32af004cfa98cd671d61daef329bb203edd74d2999974447a00ea61c368432aaf59b69d392fe3d71e594235e134984e8e04fab039671f122c6b76cc7a4e59af60808c4c072048960d9fa482de9d734222f72402a31065a2a1b0f478ac20d41d332268a6e79c941095d1f6d95c79a47395c95072dcf2270aa1147aacf29e93a7cdb278117840da359e9baa07a13eede1d635ae0ce9540f59769ab14f88582e7de2d1ee3738e49674f4c3b877468b16249fdc3fdca47b5f9297b1c6dd2248719605430950abe28967e85d0394f8283239b2af7677639a1816a186f800bb8906f1f624cf3feca1d2de73484dcfcba6c592d616a3446af9690461f5d383e2a4e4aa8dd6966a188d851b8ee188778e5234c17e25d500b5beb8036ac4da7a84a88c388843130718bdf01a8bf0763d6be8356b2c960c1dc66455e857a754d44fe3a0b38c245f73cd95d9153f21e73ab8c5be7064c71397f90216ab7dd8aaa3bc1e1c353b8dac696277600b4b780f74bdb963fbd00e7a84888a4f49cfe42b4ac0e707e8c24cbcf20e07d1188b0e489601fe052a100d372e1d9fddf4670b56e3482ea0cbb0feac140f387ad9a5f4379bead09392fed9f476a416271b449f0d9436a935233f65de998e379c7b4b49572236cd009cec51836be7e204edd275f2e3f2936512fd6c421b8e2e7331b44aac6cc195829c25930a9e7605f92dc78bffa73678449da7ae7b12cc5b3db1a5c2e4da3c874b0a67fedebc1cdf7bc33d2f3b66fed3e5e75f3bb84c7a793745b8dba9ad74ff4b1e511c5683e001c1d482fabaa32b0b2e7aa562cb6df2affe147147cd6beb9597fc7408e1abf2a1dbedb63405bd2019d7e762a0b6b5a8bce3390f8d6c2251fc6c783b0b13a9d77d85074f01ceeb4d76f096417482f333c3548e3e8eebd68309f7f5b4b73c42ca83a5dacfeed2777f81bb9dd8e0026581d0ce91ceb2fd7d356e193fa6f74a2068c5896876608fee7c98a9105ebb035f97dccdf5a4473018fa8e2d88b9ce1bc62f587c057ec9c4ccc28fec6cb8c058757bc5aaeda6707ead1477ed09be0d1dc5dc7575a0b657af96c86addc836253d3bfc3a29473cffb6f378f16f419429c1eac576f7c9e60e701621967215a835c3b124500939ff224d5a6b944c99834ef78f3c72de86504e68e748661d6aaaab92e6a1050906a186a901953e0af779e004b572150e42b8b34fad03ff763e542051fd80a03a261d22b667e56d697fac7a983d2aee1d229b811e4523a27bd975969106558bee2476d3af01f9557cce85c75c48ffdb73570e6a7e9d727c34efd54735f02c80c467eaee9f9ce4db562b353f6dcadfa18cb03a39282155eaede430917ceaf9ea6d84ea65fcfed9233830011e58bb97bf680a7cb6d30bee5ce31a6d49063d3f8a67baa057e3f16526588417f7aca477998fabc9c3c2be9ef8a713734e99de81afd7ef54ece8fcc94ed52518a2ef2e6426501bdd72ad1b787f5c066c86969ffe8a2bd7d8870e95b5e16180badf00b85b0a580f0a895f8bbf1eb7caa4915745045d757d39dbb38a874c5028d4eb67843201ae2a29b51a2ff2ba15a1580922fe11b9b3e5008d31c3721b34fd8b97c5c54ee2ee6736c1894bafbe5224c1ee12efb31f239acaf0e655e5f7b8d636fa6b397fb92dc218308180db511629c6305845b5e0774cf1db0053ee06f760ba262b8f7ebf1a09f169a34fdee3e410208ecd4f86ffc36c23a21cf83d4a78f933ac853e31088f6f1f9b96b4d144d4b37facd298a7e55dc007eef22e2e4ee3a7627e70e07aead1c635b8a7f7a55cb10a8dd33f7538ca57e37a7aac9e9d41bff7194c6f5edd951d1d7a915f3fc403e6c3c6ecd554dd5971997cd2d16bd029cfa2950b0fc9de2d223591c81d9c02ea88c6933742ccc97da3066dcaf656cc99239ce8543ba915f90108722d7c26b3595109ef1eb8351a90d3719efcd661bdb16752e5dd8d314f540c664f17da7333c32700334250c63ffd9927a093507d8f2e720d67d610be17a167c2dcf635ffe57b19ec50ad73d76ddeabf42698d2be253ad0edfb3ffd2f9731bb009330352c72e3f92beac991fecb54fe9a5babc83f27b3820dea92f9f79e378796f865817538c4410ddfbc6b65fddecfeafae7cf6f1bb2a85e60dbcb5c7f5357f9a2454c4573199e4e64d92ebf7c392f7747489320c47748722c41cd23071e35529c17d7acd3a8d63309de8ba1a8f740896438cf7e09114f963247e66f153203de56b93cf136db071c4f256a4f898bf57ff14b092e9234fdcb0ba9eebdc344e703d06d156385853cb120fa021ac94f60e389ffd55f3bd3e61f880c56960492554d9b2da3ab3b67ee2eda7b750f3229f207b914f221f929b1b1fb52a365fa962b85682a8a5b7d15618e3b4103fe9f4f568000f94d9002fe627f6a9aeb3472eee88ffbdd76d45584e7df1cc74d85a73fbae45897052fd151102af10990ee4d0f705ac9bc8f14ef087fa0bb5f64fd46bcc69ab0d0bd11442fb098ccd5cea2d7a7da5a13bc7e240feef918170693caef33dd7a23f10eb46dfaecd66b1763a71c8c876de96d79f5ecf37d48bcaea85a629776a1be45e5fa4b81ea8101aff6862443f599461faab2b258b27d2c80f65ffdde9aa1bbb2f1075160fd99924129a0e72957a3f0d7d17088336da4c2a59b3842eddcce29a953f16b6b3c021e7ab9e3d6829d890fa93a7bad679782e311f8512fe15e800c0993143f94bcee32c01cbed785cacef4b2eabd67091619d9e959c21b9b8bc6a6be3d17da77043ce3a931716e96a551a021736fd282b67eca1f77fb1bd3d5c146380ad354c870eabee50ef5667cbb102bdbfa19afe6ef17016ee414762c185122d89287cb146bf39409b8efa83a0a6d6395ae35585084f0163ca7151d7d81b11fda58c9a79e6cbd3a409db04fd40263fc55f70ef869f2501f3f870c493fd3ee1ae3e3b688303a79bc17f3a7f276e1793ec2bab257bb641d3b4c845189456362467d7d5edcb48840334f0acbd71d92fd24483cc5885751423785854c86ab9ce3809d7d86243efd1da72a3871989ca39f6d8cfdd5910f64a21f638f515ae2be330edf85981f95b99bb109d37db19ed4085a659080a33268fd62574fc27a88399c84469a4e76aaad7fee1b1792ce3d92153c2c3ac904196cb197bd6e8ef229126e5dcc4e23d7e6d5651b9021490e1b4ad57475c6f6aa0df148e488021d666e8cb0bdf9849563cde5892108c4c72284f85a343cbdcbcd10f9c777b63fb0ca6c9e8126837e4f6fce287407c12356a4dd3712025ea16a03372b6c45c1fbfc6187a5496956a452c48cfc3284b744904ffb62bd4747d04e294d77bb4c22676a6f63621dba4f707782634e56d15ba7b25111f25f96f3ffb88119ab320d231ed6136eb90a368d83f5ad506777fdcdbe4dbd54a960aa13d077189ea09c1c1508f39e93198300a02ed9c7132a3098454cd16db07f3e0c67ca45938dd918388d4b4ef6766b857d626e7876e3c8787135c28db39161b6ad748b08541c463b5053042b481e6b19874f479959ceef544e3b46a309f5f52326acff3ba426c4770997a25799f4a4165cb5026ad44d413a6985d64c5622d5c5eabd856d27ed2f919effd01afe1b5a0df092abfdfb0b7e158d7c732a2dc42bd7ed5a55e01b2834b680bc25ba9feb84d5c34dc852a43eb1007f722f49590d975f04efa8aa7b7bb8c2a591829e28fef38c094d9414fa7190cecb0dfaa975db3be5ee236ee78a9f03fdfe2a01315b09b8272f2b0482e7c3851749a415828f730e48888696bdd28f551e863b754507330f3c24d355e546ae535bd952433642836bbf3d9335171456f2335e5631712e3a0070669a4b44cebd51c2af913e028c4fd7f617f44cfbaf3a932ca6f9f6e658136dcc7ddabdab9abe86b417810fa64e74c6df0ee7aaefe81753e774d6ed96c5584bfc486d557ab66c8347ea11cd68529c1e4fb3eaacb804591ff0895089f3abe23790c5f8447f8feea6d423d9036f08e19b547183c82905df2031238778a5bdcee3c346ac8f0a977a3424bfb6233f7afd56b7bcbcfbff752cb28175583409fde9a6d1222e792d77344b0fdcccd56bc42263aa408f4ab0dfee98c3617e9106a1ed0241bdcd9a6e9410bd0f975f479c633d0913ce7d60819699c8c87511cfc47543533df466080dd25482f089b7b07c922f38d726b8e84af4407fb4bc40328f338ad14d5171d0c9999392f2681faefcb2ce2820022a770c761267b7b68f5f0e839e90ef465d21ce09dd002f1565d4da2d48eb44b4c70901ceff2cc0ae8da2ce47cba0e7c37c5ec2bc89e9b0b1e341328a9e6da75da80af6dc55628ecf82d3abafc6dd92c29f5c24b344d0bae1f50f8821bf6772b3aa4d8444070660312676fab1103e656683fbe98351077bde5e00df1231b54cd71838bec7f30712b7651fa153d82503da122547e8c37cf9da2e714cd7f261205db40eed2cc6046c9acc53a7620573cbdcfa70d5f4a26dacb7438577272e0196eefe3556c9e4fd6e712789f625144db83eecb36cc60a8599b4c0a75609727b21176ea7ba345226cecba745c4f6ece42e5b30233787a7e3bf07e97722955a1d102af6c8de1d489d2e481fa85dd218d47243080143dcb2753d0945c389fc7e7e010bb115374e5bf123bb22003328dbc9e753fc4971ccd07f912885717f4f698441528430062a85f7fb2e89db48206f82311f3fe1569c0a47835541a67c3567e90e70b7d0c9d36e8c1340d9439496c514d750cee8c0df33e6579015596f558b688336219146759a36089ed5f6574e7bd08d419280060e7f63d0ffb6fe511da87b4a434fea9824fd701f80cc271f9a64995c345d3254c69c704747846daf88e4f5a1beffabe94c2fb1e8264180f069cde6cbb5ecb33fb3112ea048499d85310796d88e709c75ae9a79317db15e59b84467464117e78217552c79d653a63a2959ee205776fdaafe2887001df2927b862850c2ad300c987f86dd5739b385ad7afd1937bdff67739f41fc31f6126de1fc7326d9f2100e7ca97d30bd815d3145379e024321966bd299cf0e5a7d769f043f84ed2c0cd915d61566083887b88a76014ebade3cdffa354a2996987d06f1e36e506e9487b6c195e87873a3b0be67f721b9bf0e7e7a88f35324c21400486a9bb13857bbc21b597493c79c9817ee53e90707ab8e8de4183ce2c60dc69abc5067e7213c57781cfa4558fb1c3f35bd239429f7aad0c3987aabedf12f27dfcfd9c9abe6bdc175803f43d57757521a8b3d4492cfb311445919c8fe9a6c16aedd0cc3e7958bbdefe949501936ce86809e13c0d28c6a8f6ba90c4e0b698b77d23f75cda3377bfd93051c166970ef53533aa5d4219545f47795b6bd84fa101f9dba2608b0b7dc2b11293fa3d38bf85e50aa21021a62ae0046de8dc3d0070137a50901c595ea3e42d8befcdbb945283f5822c075f412d2f947a926c46e686e161997685df7a7d987b33cba9659a69b76a104197fb99bf193c718089263633d1a1899f5ab48f1dd3df4092ee74b9f317837773e62ad6ac829cdef39480cda9017d3055ff5729526b89a286fe01b333de6fca75855c47cf3d093ead74d22eacbd52a1e26cb144d920d0e5b05e6fef66a488abe7ae8802cb16302ad6939cb8fd2351bf1c93fc1a030566ce5576d91fc2d5629a7bfcfde75d7938ab495bd98412948e38d58e5de2e5a92d49d2178a762fb065623b3ff478262e862a24186846ddf2da47ee1b3c442e676838056bdbf552239955aa4db6cad090f51784306e05b26296e70abd9a8b9f0207d44332bef3afb11e16d48595e7387775745c3bc50e9ceb48c06b3c87fa12e805c75209e59f2646bd1b0e158c477451937795bfdc13be6ec9007ca79ddb29ad7cce68f43b1fd4e73bee1471ab13618258c2b516ceda09a8201b0b7b4b638e5949029387f648dda42526ae3cb58f280c8d682cd359f05401ac4fd2a1c73ff41e2efb63ef98f8a1ca01e8b64e0f92c05a5cae48178e9fa917d46df59f5af78685c2612c882a99777206f92e2324aba8a9f9bcfe37bdefcdf431451902fbe94b7158ecb08f5124c3969bee8c24fa47a9b40c34331533cfc81d768f9082f35851dd9ab52cef1406995b51ecfec2289a6d26a5b4cf52a3e37c321a01ca779ff8bec18e6c4d0918752b726c44fdaa52edbcc93eea34f99b27574ebd5b152dbff027a26ac675dd906b68474a6a66a0a28a24d1d8f64ae283d2955bfdd8328ce3c5edebbd9b9b27d4c6152ca30eb16e58ef529a4041f6d44e8febe76396ba87577a577ddda611ad7d5d346494a7d1e322bc3a50b2933d8c47847a28db547f12389447bdbd4fbcf5b7157bf059719992ac8f310a411ad7fbbce332d7e7b54196e62b1e874e146e0d63b7643f18090cd38d2b60ca683431c8cf0c7e8c931ad8132179b7ad601faa9fb4673a11dbcedc46493ef181a1224fa8314f4a95c90aa6fdbb69ec3878254eb1f53f7981304fbca9ca76cfd484e95fb7c6466859ed9b3fe6bafcf36cdf336ecdb40f64d80ab476390b2e56d6fa5ad4107817f48419a182926a03567bdc9b6c2c2b257e5b28c8446abb1f10f0db26204cd2a0f7efbe7e8cdc0d59238b55241d04575cf431a76a682f969e361c6701de11bcb7fd0462e47720755aa69144cb865dcb4af51a193fdbcaf5a59343aeb44744ab10a60a1340e23fb693edb85ae69869be73ee6d3311401ef65e851cb7b879052b41eec141a52445c68b769199fe0bc70bdc5ad37a13ca4fc1cff082e5f05d94ac8033c5270a5882d694d60fc098df78161f676a21a2ae24b39ac690b28320de25f029cc9ec0168211ad4b757d3473be8c5c21918b8d4737a626140b60697079c1c189c21ec93d892e9ebee959e278507894beb19e5f86d9b8aeebf9d8d20f4584a765cd4690a6eeb36422b8c8dc0bc8a339ae4ea3eda2d80e946daa3e2148679b6b605e3390fcdae5c2ef94c97906fc380952eebb9e56070188c629dadc199d0f015a6a0453942812583ddf0a2b0c18a4452f51ce5b46cca13e0d46f0bd52d0cbbb0cdfc38ee24ed6bda7a233c230e291da36dd8566ee83b2e44956a6657ef1591b2364c7a6dcd42e29bd10ba16f99044037610872ea5ae2627c3d58e72d171418e82d4f5e1b58de515a4203d7456dc8ea577838fbe34700ab7ad031b2feb4b806e821f69786b7681c8e5454e28647dc95e31d9d15bb787b9a24d83eccc0f873450a658a8c2d6a9b85edf4ba43b20cce6693c68e2cb967016df4dd5e3944ab0047dc68e56fce373c2a79603bb7eff6e03f4825f82b86b68c6daf96e7692f65b170675fc865d6ec55966e56286ec358fd58713c3eb276dcb97a0db46e73a8abf5dde7382394224dd824af7df2a79bfefb6f1947d3d72eb2f812deb3effcb5e2ad97368b9099ae8dfdfe049c15d51429039f27d84871bcf5219f6b2b3144e8450eeda3c8aaf8ec47c26f22a614866351dcdbe5468e0e155efa309c41182a612e07b8bbca4580a698351a2a495de3b6af53386a8ad956e00b7bf78069bbe1197d49278b7ec01dd2ec922432c19a9104a733d2c71f1d65dc138fa69db6191d69aeb448d1a0aea1c211201ac2dd64f82057e6702d00ac21cc3992ac8e4479cc202fad95dc03ab80b60c13b77a65eefc7632f8730dc3c507edb095d187ca34213bee24bc0b6ed4e50c094ff1086f7fda4c152dcc928e795415e41049055e80c23aadb3296b5ed8cad81d8fd84ff86913fe32e0717e87d32fd020579b09d0df3fb32685c194f56aff8ed0665308256c3326008421ccf873800be137ca4c165634f9994c077060a3410706287b7f1fbabc43dce81808afb420aefb10209b0e572c67afc92ef804e51916dd4ccca817a37ef935c89fc03bdff4d4d3e77352d610403114d5793233c1631a6cdc84a55068862cf0d7699aefce3e0a867ad429960af4257f8bf451a4f7a90d7c4af5673affb0387735441877d43994424290fe963b52d8726f37876704662004a067b8ab9a5cc244db87d4b9c8b3279b3cfc43f8162ff0ca1f21523b43f0a1b6149106a97b69d08fecf938b47caafd00d52288a597c845dc20e141fcff6b1291152958c23016a8ba5de5b44fb89a2362554d3fc46652cf282ecfa27b59a3b0b72806e93bee963e67e5cd8aea469a5d5f898e44aa3a85d7fadcf321b922a6de9a1e59d22b2769ed5ee83c74f47a5c588e2c40867a88d127a6854118d0850d5b5cd2f9472dd7d9852643a09c763f85a1005e15c4185be9b0d1111207c036dee5ccbdfeb2f9ba10f3dbe060e148a119cc2d596e8340b02ca787ee3aa4a5024c10dee177a42164d1b0dc573cc9710ce3558b56beb7c80a02ea5690d02ec645acb4833651daeacba6a861e038d898f9d17346cf41766af8919076e95dd4127a45ba94a932dd9c627dc7253226d07eb4a4ef8f7adf697b850c4d9ebc280ab11e9258689b831fdfe86506cf98456f1d54d25a459381dbaa26abbb23455a0ec4a046a874bc05659f412fdee27093723251af4ec7a0d0133a6b9b02731088f84874d7aa35c923d83fc7d8ad72add3e07bc0b1506018348da94e795771dedc45512c492e95333fdd7a775c59ad19c3ba348e9f3e131154cbe04ac7ac9a17653b98e62604889cd446b8aa712900cfdb364870cc6d712bb0a3458438357d932797c0062000c8e1c1de5f41dc3dd95339e9a759ed43eeed7c35ba35919c2c037bc06d98f57ac35c6ff2382a200e7e41731d13bd952a9abdcea611387c9491d553fb0ad7a594d8f0ffaae4448377d08fe98f0591e2c0d937628fdffe873bff7d3d3df070335717ca492a55d28f8d28beed3e467fb95fd64868a08b6e27ec900ee4dcc88c2701449","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"504e7209016275ad87ba7a4ee8e365eb"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
