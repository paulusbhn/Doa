<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ca57c484bce02b0250a4d084d075d399e1f8e3e60120a737c827201d41431114c88117eae04429ed7b2efa233c670a70aac9168d1b2cc15b1dba5a69241fbe6676f0c6d2ce659aa480a4b6e71abb11aa7f7f2578b09d53ad6f25c1fdb7ee9e171ed906cdd96da78a142cd81e6b9dc16a03d2423622fe1dd2d4e1246e65c1d54787104d361e0a86001b45be80e91ed80a6694ed1a2360f7be3c080e6f136fb96b8869325373e58529b0eb4c8ea54cdb7e59a112971bf86d46ca2ede588154319ecbdfe5ad9a277ea4d9091e1546b0ab45049a612286b92ff81fee713f46817b0c1570bd79e505ed58648f78b731894e5ace4b90433f929b1d22a573fe382b161ebce5f38cccf22249b6bb18d7fa53e83a6aad5ae3ffe59cf5f572c2814e51f4b1268ee6dc472635be9ba223d590a25f9abee81e6caff94052eb68a2dbcf710f905ac2324df82efdd44c1963eae29ecd77543e0096b4fbd7f99d14c57b2edb3af5ebe50824b49c46f8423f0033eb2dfb598952ff833271cde4e6951a44c519cd40c9cbefadd836e0918b3430b92a36c81ee77bafe053cf2e02ee8b2d522a79caef07eb9cef6301d89f953672cc65356ccaaed284638d07b00c989fcd2983b2d9004764e8aa2674e9c19bda302b459cb229c4f8bbd0a70e02e65e3a0eb799f0818b763ff2857dfed819624c4a3065efa2e27b3be951de1788680eba0b25c2a9bac6b62d791de745f0c397404ec308172ff9beb4163457c7d9aec18b9be83e80167c8ed1435564ccfaf956a645ce3b94305fa6330f1074a70292e63dd4ae342edede543127218260e343fdb09c46b7570c8ac52fe07ef4933a2a4362f9650ded093921febfe703c6463bb23293e94c9e492e0ffc813468051f02efc770ce3ff79f55b36114b23837b913d06bf544a5473fc98bbf632175695f44837234d9c5731de7cce8762cbb9feec31071f7af44bfe92a15fee47b377ec88d5510729b6fd1fc98552044b36799611608d5a5bb9165b9505fc5cb75fae5014fcc87c637cfef1da42a85fe3d5c2890290622bc59dee2e4f751c40905886ee05559b99cfa0a3b0ed40c4db34359934a2ed75351a7ff22742b2118856a0cbd1861bbe0c5086ed2b4cd780badcd1cfa111b68ba7f3952b95ef83d1ab8ae582cb0340a78344a3d99a20537d22198ead0ebf8f73e2343724c14b76c5af21832160f3a77661cfc056d7af8a359756b0a611743f5247fdcbf979531c9fd72c7a022cd364ea65da2952ebdc5d62e2054c76739c49f4926807cb12da4d624e8f77561da3650757ff6c0c05d2e7ad162090a6e054c21824d83c770ca864fe11c37b605eaed1b57338c352a43d15d66b4e2eb3dca030d3d3e33827b651de52377d643c0000ce2938eacd5a842465e6a5cee2ec4c802de9c5f6b49d10a32f8305964d5712244f88ecb9166b9a844938a8558650eeb899acb65b07e92463aa51c72acba4d8e17567f631da65d0dfcdb06e8a1979d2da1420f11ef9f547e0d11ff36831d1b71a8acd72e4cd9c2bc1813681c84bcc63d1c9602304bf522fd9881da57352f6df56f6bc977d51fa150b457bbea0220ca4c871af837927fe72dd0beed69fe3cfa9d93a3b9559880f6505b6b2e3d436f94e4098d943dfc70529fbd1b7fdef5a6d89ccba63ea69919ab6725835c1dccaa6d2c446a44c6e1d9217c354b209becd7f0e5b70175b338a7de96310968829d049b9c01270f3d6158fb48b11353b8519a8a743218f07c478cb7226f1f3b2aa4e8205574c06a1c52aa0a475b36a31599cc5e43e1f83bda3ed6a4772d9d950524fad4e5a96a5b49d1c4a67a6b4091b89e8a858086c6dc1324068447d7e777d28b2726089c0a780628f941d662c930655c132f379e57c8aec5a80010ca7ffa1beec6d74c00e1d64e30095c526ffe0cf81e2036394e7e6171dbd061596aeeec0184b22e6bb94a98b0a681207b132a6f62c0d4ed72fbb11caa0685ad228c38e39162e6f7f42b4c18e8a31f623a6349423cdb3eb7c68824792d13ffa8d85580ee0ae7f78972b997527911c174ebd994ec9cac09e473b1c6a7e262b6643b9a8ac125707103f7aacd4106cdcf102cdb45ee03fd8943e137fb4cce8b14e1ff047df49030f2c574274e7f950a3eb574885810eddb14d98234747238c7732d95f7ac29150cb1f283dc8f3a080174c8d18916ffaec02a7a4563e27482d776d22b16c3200999d3fb8d2f1cb2d420b0fb5987ca5448cd3b42816988d25c149f3220b0464ba29cf87b5756e91a8b6d6f78a2d3f7277ca916852b7372c1a4895af5f77f33fce33aecec696a9aca0854eafef7a63cd583c04a92d4ae0c1ae769f10e2119cafcbec3e60dd2081a9886e5f089abb43d7e5644dc17d6129c9933b81a22c0e148a747341e6479a7be5316f21f597099e805479e0a9f43ffc7ee5f121e54deb6e902e7177b44bbb478e1a9f274ee183beea65e4426f779eb3f3a3946604eb8d8f0f98fac4b4375ea4bbc7561d28cb264d058fe0cdd3e69dcf755e995cd538522a383f6022519736c95e48f7e7c2d9172e5302e61a7350fd05c0a7ccd2067711f2383f29990e48562f4eac3f9971af2eb0068439afba058ee3ae1f32079de86a813392f21f376facd1144ebd96019e91ea3044dd36f8822fcb3a8b05139bbeea5abdf0fa1c702bc5a651e56fbe8ef34922e0105587f15e1be7769c398ce3b2cab9d8b3e5ac910931f6c26372e43ad0ac31a6935792b806790ef2f2b4ef7c0472c36ea2588c67d3dda7cadb18bf34bd77bf6b036a9bd0c5c8fdca8699daff511ca9a501c18dd5cf0dd8c52001e4dc37e34e80cb0633fc6da45f4e749a17fb0a6dc178f453beaffb59f7d42154651afa9c614c477c859521e7b3fc550cf5749a7d579e32656dd800d86fd195fcb939fd0e5fe774d6e1f7c30e7deda90917bd675e595163bbd6d98cf387ff0156d19459591b59c26b7c2f2967f68512c49bdc96a47bfa2c1c167dac38cc836aca88f52a474adee566f1099f3dd7e76a493b5f60080ca6eeaf6e0fcdcb6dce54980c2d8a6f966560f01c7acc02ff25accddb1cccb8748a1c6eb5d84ecdd9bca88114cd887357d655f2deeaeddbc2deb8460e63cf1fe96d1f89af7d807583730fe3706046ed08d6519d2caeabc6eaa9c55bc8b449f198d69678113d867fafc2c740d05f8cd3548f545c8d88b7d793cadf239b939cd41a54a7a169105ac8859e056a38e31fc6948851eba7ad708231e13fe1fd63fdcb5a92d70c3c87efebc7e39591a3bf3d6a32a56d9d743c6a9f959693c3a3ff7535b7d29ac93ced8e7c58842c10a83b06e63e5b877917bba72e786b908fc3d47cf5065051f53a68d0cff70b8068e89d82b36849fa084a6e8dbb80a54e79a00251bd6212cd0ea6ffbd49b5d6b69d6ab03de66fba71fd787a34410944dcf25d62b2e05ee6c607c449cb088a2cc1225acf30df3757af7276f306de732ea46b67a5239d2ef99633791ca823916a5d7e8c45568e5078be3a3f979199f0f16c72c8a191eae079ce874ba3444a9e1270dec995be4727f56d55d56eaf6588014a9ab6dd1498828b61b96878fd2d603917f294df531eec9f236ee664c8f546d829012ac51d862a4e7095bf6da2e74b7422c484c330ad7c65c90ed0967b191ba792a863bb1b6932e9a17c245be55a32a352a9dbd5ef45c6d7dc605fd8fae3a747ee53dbe77275f263d47b4b91226cf8aa1d907b104e06821226fe03f5c6b3f114244a2cbd588016800fbb3efb85ed78c945712f0f5014360b63e1ae5e725a2e2202c5283e430288bd00abe3b76d2d42a6e8bffbff13203541be13aa76b795f659bb4b57f4cbe4d918c660412a9002e961c9173d3fb0baaacfad71ece8d3e5d63efdbd1600fff4ccb88c822e7934354d9038614b50281ac649076c6a0ce5e7f1ff9422e9b4b27dfaf7a50a03c473012b55131c09b990d59a0f5844fb3ebddfc430fe2ad887ca6f7ea35c47f45f6f1c71776befd8c34777eda20cca8f2f41e80e9893e528da65d1e31f8fdaeb5aac88b9c6866699df0c5bdf45a9e4230ca1a922eb37b084e338601957751b03aee521bf2f6b4e5fdd737c10be09426117a68a3efea38acd291fded3e9e4866c32a19e42f5e6ca443aac6ba54fdd31cbfdaa8032d51eb0ae57bbe60c6d18349b512c037fa688463553eb7a844e9bd8b1fa68f9f40c5ee02a8051e1d918dab3bf7d348ae0b24d70fa28cbddc505c88b5604f64484f23da4bb833036963fedb923e5890108a7d6a76e92bef669947a0958e78452019adb809d10449248d64c1730a625327d1ee8ee7fe42480a3e32aca289aaa04fb8e9d1c1670cb717b3ee89ce9aaaf6bfd5c25cb1ebf4573f91ec76172687e02a33c3db8f268f73af01473076a865713e9bbcf71cf32530b48ec938c1473fdb7dec8caecde548face3919b7488f1df399bceb58f3d877959b5a3fc5f3358d5dc1d931baf7fba377148bd4dd62753986b87556b9069bd3754ce5c1c10ee3b990b7f76322a68acb7d60b5630077415b2af597abb418c6509ecf462b26328b1c073532f97697040bb6ef44b553ca433ac9bdccc1468e86036bcd080c63dd3054b53073a3b1d0d73709558a1f58b94c1fc1c555481338a1bfbf3812e6d2cccc743898bc7d51b2d9ec5bc71de259506935fa16bd84f2537b7fc39fb3c90cd8cf5e7eaff40bc75dac1d201f9cdce2c2246794c55d4cb321debeca78df1c9cc7f20192741dd2ce93186ccce1f7d0cc843d5c87eb4e78adc94e683c9076338b5af0d4839425f25cb9ca707e4e4b08877a5565ca94d521ac0da93e1d3073d775cd36f680fdc2fa8389ff1e1d1a350f564efac3e454676e6efe31107012bdd465c6ebbc48a85c094100f58b69768644ef7b5878904fc874cfba656e66c8ca474517c64f000b2cb62334054e9fccee9dc72f97702804a2b474290693c708f7bba824688c328d69ea85db3eac2efa10c2e255dcb2e9291f5f81faef0d3f618f57fac461c51edcef0d8a0ac98e8ff31e05a6a893b960352eb75af6cda5f1433b7bef8dce6486b09e4aa230fe4e53f8dffb27ef81a356b5bd58e8e30967c120f1a9dafa1043a3821f6b8e4bb2adfe83b33d45e685a4ddb566785b13677da5ebf944ebfd8d47a8e595fa7c9015a4f485526639516becfbb8004e356a59797e053bd606ef372fa222504a3c029481289f5c62b9aede2e0a11145043d9ba9380ac935400d87ea0b6a35d0ddc19948a79b50de8a6909092298eb8d69cbdea809ebd7ea177961e8c2130f2b04ddbbcb03259c933a5bfdbed69c96be8f8ff1d9c8c65f01c3230d2f25cd8ba91cf140793026d23b97cf543d620e59541332bec05f9116294093022a22ecb72afe3917c7ac3edd7414cb848d250ca75e92d44f4b7e79f95a50fbea2903d4fdaf7f654810ff2301650485e96ed65302b96ecb12c36391f745e009620b9c8b630b03697eb975e975f2f8779a63c89412139c4cb47ad3eab634762f0a8973012ca8539c76588bed721b3d71c79007f3c83eb848ef36cb43f7dbef47c7c99ef950eaece2b94310cb6ead0d5b77fcccb0bc3af06f8afaef2d2b2d1542198c1123c2d2aa50f4059def3651651abfca61043dbf5a8852528ec1ee8c063b08e23100f5997a282f3de7c4f6d322de7b8cdd82590912ae724402fbb65d9a14336d2e5ed9e2a45d8d4d6fc620c61d95698dfd6aee14097db0d3ade97ba1e851b7b5db9bd9691feeeac5bbc88172bf6f77c8552b3809527fb3cafc929314e5df6242db3ac041b1cfb7b7c4c8773d721c2d8ffddd801606d5ae5ca0100ed430b8f0ce0f05144bc3bea51263afe40cef80aeda74b5ae33d9970aa83e1a4cac477b030a862d97cba4b3f9d045587730e8ca8d14b589e36bce2713593963e0f1da4fbf9be810c040ef62bed6b7799dd8d330452a8d7f6d4a65719e225026ac5078250ac6d8bdf2e37c7fea086c4e6f4d8fe5030dd97ce0ab28a8b82680173c33157c563141c3c16fd21de5d26cb4de799156f2df1310853f7b0bd80fcbcf52194802c35997b6eb361d031e95aaca8a5a4122f869cc76b0435a7b910b7c1617732686e65df9703f96787d760c33314918c185337b0cbed40dac353ee3ea4095ba6ad3f735cbf09552a727106347e456562ee694e474b2ca540cf8bd0ef63a8dbdce3676da444e73cf3566cf2dad66912a02ffc00861b5698e8f1ab3237c45dbe5834126d8c6e2ef36aa20e0b945020aebd27ab739ca19096016d2ca15c587ffc71f29402d98f44efb74d789c08bbb894038d4ec163763bd2de9a1f5a6a7166b0e55f3d9aebb7cd902c649fe60c0581758d549046d7667a0744e2837bc1fb2fc1f7ef503425a8a730636f19b1fb2e4551c62073301a9a6d08fb93127b337c2b90aab22d3e2071cce9ea6b68bec1f9457a49342657197e63583641c771bcf6b2f9f29cbc2d088bd8cb0a2b89ac6185a601eb269ebe79da41d591246ad4c9011ae7fdae6de459255a24e8611a93fcc68c69a1d5e2b35a8d592e44e669f40367169c41c5f9ae40fef50e238d34d61cfcd47b77cce23a1133c1d4ba9f591e93db2d177ec8da102177eb971e478bc94c593e046d31c83691e90f9e6c71754bd4ae1f17c0ee9a45f3459e405b0a8bc40198d151fb27777959e172ff18661ec0e65e618ad2284140844bf272608d9b41146477ae26bac930a4133cdc3dee8b27c46702bf88c81c3361dbfc398ad9be2cb30d7e649e1095033c4428a30ccbc2eb73950ca70750751cc0b85153913e57fe53d0ea06284038f768fe10c22e313174758ade199396b94ae29dec20f0dece18f2118b6d61357298bad86885ac0769cc6221ff9a1cc00a392f8ede530f5b91fa5ccec9dc01cf5bbb7c45fb60ad8b602afb9ebc12a4619fadc41fedf885788bd34acba75d20aa50f18dd66f965c4efd1acd8283027725ae16db5f816773cbabbc3e2865b4e5900e1ac353ae9ebb2a932d3674584c2f6368ee6e55c91b576708b7b3b576a83a5f17b5c7f9e78905c4fee5bd5cab6187bdbf91826631daba440ef486c3fd59fa493951fb243bc4e03e19d0d5121b9a46b2841b640541ed1417a48c76253196b80b1117b4bb98d76e77ffb5103dc6a971aa35a20103a25a77d8e3ccafab49038cb5a9e3d2b0ae6012eb2e43589df0812d8872dc21533463685408ecb48d6059520bfc30360af014338f5f86c733e456fd5d4963e3e365aac8c2b9e141f2bd100a4d50bebea17ca316ee5b93d4dc1bf41121c82ef14a9f8f0a28b317464c51da53513d578e016b22eafd4bc581adc482ad0a75e657ae52608f1faff1e8f168e1c296e6d7ba4031cfe51080ba6e938bd44df7a142d6015285b5616cab7049a2fa089303c511978d17d2cbdb4abafa60242fb0ac1277a90bd7515a8bed032d86074710b1d80acc091367034e7b17450328668f38cd6a7f59cccdd9a0097c08ea4849d73e2e8fa69ebce303437a81dff12d54139054299c54c4f821220cebbd50d538db1a8a02f0f0b6128a4ec7a72ad6900fa7a6ae2993cdd726ac3827b25212194d5d37f1a89f3cdd749edfd234b39e3e4d3b96e0500b14aae7d5c8047e0d71c3bbb990235a427fe7f18b1a9c02f35bea609c90a06913cb37c5e48c8e3b85fbf8570c1354b30386a00316724596e8f85642d0102d8d0e364ccf945215a322e321afb6e8ef52698e2e03ae77b020acc1e365fda1aca8b8d98674fd158f83c0f5bf6784fe2af65d2c108dce9f8812495765516607e2b34a9bd38a4b7794b44fb552377d059e6a6b524559913bb9308d19d0e04d2676df47e961b53bad825dab12a6107a7c23593987fb4f84c732811e1eaa597d86033744b53c6f9af59f0df962fd9cadd6de5f4a9f979526fc6d583961a0f4d5acf5dd7e9d7b37c6f5345a219653c921907bd93b289eeb31bbca335b176882520e4fd6c1fa52ced4ac724966b992e628ff7f3376c73a87fc99d36cc119c0086cee066009c1edaff224c70373135858e258c8bc6174b730c31231d957e0840cb515910a626150a122d2e6f735af62db567f265a9806309bf5e719d40829ace107e9b9f6dfefca289c1bc17cc441185de713c1ee130d8154df8d84616075bcbbfb3a4f92508591b18e37b6732a2091d1993068ae2c3a1b46bf530d1e82205c1b3a089a5b56c41fc2656b37c7332ea93d200e41ec7713707745f089860b6f89af85e99c7dd065744331a65540bd5e599a263f2714fe55a8af08b7e1def67ac8fd4dfc1b386f5327cfa1a4f6ee1db5ec477f4a0ef9981c85eb23df239e0cefb4633362fb7e971449fd4c831ea91425d2b7ccc611474392122eb60c5f10aadaa3ed8cb07a881a169a6471289bd16a32edc93769d635f035624fea78fb307a98a66cdaae88f80c9fa4beb53771bd3e23e48f41b21882359d5c22ce26740c2d101ebf199613f0faf03dd1bad564d1f724d3de07fac8e3698860773ed9d7a29983a3a0369a0292266e3097bcfed2929587a1eb99a0baea2eaf69e360fe634bd29dbb2aa97ff73914bca482dacfc1670b5f3d42146b3c927b71db9e3f4eec8a0907d902aa1ba4424d0579ba44cc03f3845f99bb47d4ca45eebb76e7cab6e09a37782053f32f271de9d3ffaed36b7f9292c138f3d74b2dbabb999f86c232a0bec896c44a6c3e31b70aa5ec861dc1bb2bca00dc9d43fe80bfae1aa85fdcd3936cb2d7070cde02bbb528b96f21f979758ad8fa84804ef8b021ff8c8dcfa83626c8c7e8d1fec692df2ee5429b8dc4096b51e72978d29a3ded9bf0d7153132315e786048fe654e11b0337d1b4e2ad474adbff90e87002ed65d05ebb2ec8fce1d600f2b3e4c74891d2709c79db2a6923bb16afbf4ec59cb7c3698f1ec4269c6f52f8e300757a686318937716aa5db2f618ce0a20bcad56f9b1364804eac228f6343f76371348a9b75d8da8e0293cbc0b29471ca4f404665da877fc8ee266c63e85b039c48b2d86175c427587daefe3d31faa1060b9dccb83cc301dc9284fab1628ed790283eb242fcaa71b6b0bd683cf054796a58b0c9680f60d9104d80782e168006a9fb8f3617cbd2c9e69bffa593dd664d116d19da9ecb789621f7489e6571f4f56fe6fafe67ef9314d1e6046e1517280c46500c689bcb146c1f0c7c02dda89c8b317f40a5e6b415a977a76eaecbd31708e6c22b818b96727a3ed926d53b34144c33e362fa8810c6ca7c3bba38357f75715b1fb0245c65ebb9793bc6144c1e0bd3efa11c0fbf169de78062eabfaaa0b8351c60bf2e2843254648055ac8e69df3908a4ad8897cd5d941cddb799a9f98cacaf9a7255ad6b2fa1e35ccc3a38de691d8f318b625fb29ba3695cbe2480adb549e05e2f0eed2e37ead6b680f154fdc3e6581c580ffc8ef94cc61208b02419fcb1a4392924380be514e0340da4cc07cf9bd989e2a8fd495640e92c7cac172f8a0e6c64258ab8c4367804e8468f082415828e9fbc1ca09fcd02986b08cfd0caff94ab4207fae3e6152ae932542e8c73f1a3a074a025c281ceec04a337388230ecefee418814df1cafc6a954a01729354dd3f9367b06e78900000d0d37363b7237cda4de3396924e2735af296d05acd50e8e3edd6a9b14de5f6a654941ba7311ab9072ff2a0c07e74260ea62b2e6260fbb21c0893aa4d6b0c0bfb5291ea0b00f825e8c9e0fcd9ab2e3fe62b20b2d768dd116c8fb02b40c4dd00e555756a532814270bcb3487b03ab4e227a6450bf791653730b2d1b61fd35a7a2cd38745278d0ea1d75390c3376495323dd4beaca1f7ec070190976de13a375e18881a11638f0a4cb359affedd145d91c5b281459a8181cc625fc8623bccaa910e42b771cbaec946464682873546e3d8c0996b64a83f394429cdfc35201cb0d50847ce8b8a615f128dc6d9879900606e119d74282fb877f26cfdf87de789d057848a5088bcc38cc4a1bb8483f4b4761db8bd667ccdcb5c571b56a2d52d3bf786ca4f05bee2aa03e7614cf8612cb2c378a34724700238f575bbdc01a8c32b95cddf56b8247c6f93e5903ddd8ecf4a15cb9a446e67861a4b08279a73d87a7076f9bfe814c59bbf21dc43741395e1c9038dc2ee73755ebcc9efe6905597f2de4f04421f48f620f3dc4fd39a864b2e5c1a863b1dbb7ce5e1253cc0257dab10cb5859d8dfc078d637048348ca6a0385bc354c34b7e829b9d2d0bed234df17b1f472d426d754cd1e1c0e3fdb3c7e01f6283fa0f17f8a76dae2c7d1b15d929c3d4d3fd6e3d02dd29d1994f09010b00a7066c93ca529bd97465677da46a2ddd2754705f0cfe9b46962fbb513d0afe839871b0486b4162cac3c9d762dc1dfacad3951fd9b13fac9fd018805289c237","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"64bf93edb9077e288782229141aac378"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
